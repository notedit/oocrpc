{"body":"# oocrpc\r\n\r\nThis is oocrpc, a rpc based on bson, you can call the remote golang service from the python client.\r\n\r\nso you can write the webapp's frontend with python(django tornado flask), write the webapp's backend with go.\r\n\r\n## QUICK START\r\n\r\n    $ go get  github.com/notedit/oocrpc/bson\r\n    $ go get  github.com/notedit/oocrpc/rpc\r\n    $ go test github.com/notedit/oocrpc/rpc\r\n\r\n\r\n# go rpc server:\r\n\r\n```go\r\npackage main\r\n                                                                                                                            \r\nimport (\r\n    \"errors\"\r\n    \"github.com/notedit/oocrpc/rpc\"\r\n)\r\n\r\ntype Args struct {\r\n    A, B int\r\n}\r\n\r\ntype Reply struct {\r\n    C int\r\n}\r\n\r\ntype Arith int\r\n\r\nfunc (t *Arith) Add(args *Args, reply *Reply) error {\r\n    reply.C = args.A + args.B\r\n    return nil\r\n}\r\n\r\nfunc (t *Arith) Mul(args *Args, reply *Reply) error {\r\n    reply.C = args.A * args.B\r\n    return nil\r\n}\r\n\r\nfunc (t *Arith) Div(args *Args, reply *Reply) error {\r\n    if args.B == 0 {\r\n        return rpc.BackendError{\"InternalError\", \"divide by zero\"}\r\n    }\r\n    reply.C = args.A / args.B\r\n    return nil\r\n}\r\n\r\n\r\nfunc (t *Arith) Error(args *Args, reply *Reply) error {\r\n    panic(\"ERROR\")\r\n}\r\n\r\nfunc (t *Arith) NError(args *Args, reply *Reply) error {\r\n    return errors.New(\"normalerror\")\r\n}\r\n\r\nfunc main() {\r\n    newServer := rpc.NewServer(\"localhost\", 9091)\r\n    newServer.Register(new(Arith))\r\n    newServer.Serv()\r\n}    \r\n```\r\n\r\n# go rpc client:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"github.com/notedit/oocrpc/rpc\"\r\n)\r\n\r\ntype Args struct {\r\n    A, B int\r\n}\r\n\r\ntype Reply struct {\r\n    C int\r\n}\r\n\r\nfunc main() {\r\n    client := rpc.New(\"localhost:9090\")\r\n    // normal test\r\n    args := &Args{7, 8}\r\n    reply := &Reply{}\r\n\r\n    err := client.Call(\"Arith.Mul\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n\r\n    err = client.Call(\"Arith.Add\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n\r\n    // un exist method\r\n    err = client.Call(\"Arith.Notfound\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n    // un exist service\r\n    err = client.Call(\"Notfound.arith\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n    // test error \r\n    args = &Args{7, 0}\r\n    reply = &Reply{}\r\n\r\n    err = client.Call(\"Arith.Div\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n\r\n    // test panic\r\n    args = &Args{7, 8}\r\n    reply = &Reply{}\r\n\r\n    err = client.Call(\"Arith.Error\", args, reply)\r\n    if err != nil {\r\n        fmt.Println(err.Error())\r\n    }\r\n}                \r\n```\r\n\r\n# python rpc client:\r\n\r\n```python\r\nfrom client import RpcClient\r\n\r\nclient = RpcClient(host='localhost',port=9090)                                                                          \r\nret = client.Add({'a':7,'b':8})\r\nprint 'Add',ret\r\n\r\nret = client.Mul({'a':7,'b':8})\r\nprint 'Mul',ret\r\n```\r\n\r\n# cpp rpc client:\r\n```cpp\r\n\tbob b;\r\n\tb.append(\"a\", int(7));\r\n\tb.append(\"b\", int(8));\r\n\r\n\tBSONObj result;\r\n\tint c = 0;\r\n\tif ( DoRpcCall(host, \"Arith.Add\", b.obj(), &result) )\t//\r\n\t{\r\n\t\t//cout << result.jsonString(JS, 1) << endl;\r\n\t\tc = result[\"c\"].Int();\r\n\t\tassert(c == 15);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << result.jsonString(JS, 1) << endl;\r\n\t\tassert(false);\r\n\t}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"a rpc based on bsonï¼Œ you can call the remote golang service from the python  or cpp  client","name":"Oocrpc"}